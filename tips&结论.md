# 结论

### 异或

​		 $a ~xor ~b+a ~xor ~c >=b ~xor ~c$

​		$a~xor~b>=|a-b|>=gcd(a,b) $

### 绝对值等式/不等式

$min(a, b) = a + b − max(a, b)$

$max(|p_i − p_j |, |q_i − q_j |) = 1 /2 (|p_i + q_i − p_j − q_j | + |p_i − q_i − p_j + q_j |)$

### 数论

任意的$2n+1$个整数必定有$n$个数的和是$n$的倍数

$\lceil \frac{m}{n} \rceil =  \lfloor \frac{m-1}{n}+1 \rfloor$

对于函数 $g(x)=\sum_{i=1}^{L}\lfloor x/i \rfloor$，对于任意的$B \geq \sqrt{x}$ ，都有$g(x)=\sum_{i=1}^{min(L,B)}\lfloor x/i \rfloor+\sum_{i=1}^{B}max(0,min(\lfloor x/i \rfloor,L)-B)$



### Prufer序列

二分完全图生成树数量 $n_1^{n_2-1} n_2^{n_1-1}$

n个节点，k个树，生成树数量$n^{k-2}\prod_{1}^{k}a_i$    

完全k分图生成树个数是 $n^{k-2} \prod (n-n_i)^{n_i-1}$



## 区间划分

给出一个序列（有正有负），给出上下界要求把序列划分成k个区间，使得所有的区间和在上下界内。

这个k一定是个区间。

### Kummer 定理

 (V(x)表示最大的2的几次幂整除x),然后根据kummer定理，C(i+j,j)的V(x)=i+j在2进制下的进位次数

### 卡特兰三角

前缀和的前缀和的通项

$T(n,k)=\sum_{j=0}^{k}T(n-1,j)$

$T(n,k)=C(n+k,n)*(n-k+1)/(n+1)$



```
  1;
  1, 1;
  1, 2,  2;
  1, 3,  5,   5;
  1, 4,  9,  14,  14;
  1, 5, 14,  28,  42,   42;
  1, 6, 20,  48,  90,  132,  132;
  1, 7, 27,  75, 165,  297,  429,  429;
  1, 8, 35, 110, 275,  572, 1001, 1430, 1430;
  1, 9, 44, 154, 429, 1001, 2002, 3432, 4862, 4862;
```

### 二项式反演

$f(n)=\sum_{i=0}^{n}\binom{n}{i}g(i)<=>g(n)=\sum_{i=0}^{n}(−1)^{n−i}\binom{n}{i}f(i)$

### 竞赛图



![竞赛图](C:\Users\tarjen\Desktop\tarjen\picture\竞赛图.png)

每次取等号是就是一个强联通分量独立出来，比如上一个取等号的位置是 $i$，当前是 $j$，那么 $[i+1,j]$ 就是一个强联通分量

竞赛图的强连通分量存在哈密顿回路，并且竞赛图存在哈密顿路

求一条竞赛图的哈密顿回路 ，类似归并排序的办法做

### 网络流

#### 最小点覆盖

定理内容：二分图最小点覆盖的点的数量**等于**二分图最大匹配的边的数量。

构造方法 ++ 简单证明：

首先求出二分图中的最大匹配，建议使用 Dinic.

从每一个非匹配的 **左部点** 出发，沿着非匹配边正向进行遍历，沿着匹配边反向进行遍历到的点进行标记。选取左部点中没有被标记过的点，右部点中被标记过的点，则这些点可以形成该二分图的最小点覆盖。

#### 最大权闭合子图

新建一个源点 $S$ 和汇点 $T$，从源点 $S$ 向 $w_i>0$ 的点连一条边权为 $w_i$ 的边，从所有 $w_i<0$ 的点向汇点 $T$ 连一条边权为 $-w_i$ 的边，原图中点与点之间的边不变，流量设为 $INF$

对新图求一遍最小割，最大权 $=\sum_{w_i>0}w_i$ 减去最小割 

### Runs理论

位置不同的本原平方串（即最小整周期恰为 $\frac{len}{2}$ 的串）是 $O(nlogn)$的

指数定义一个 $run(l,r,p)$ 的指数是 $\frac{r-l+1}{p}$，即 $Period$ $p$ 在 $s[l,r]$ 中的出现次数。记作 $e(l,r,p)$。

因为一个平方子串一定会出现在某个 $run(l, r, p)$ 中，且长度一定是 $2p$的倍数，所以可以枚举所有 $run$，枚举平方子串的长度 $2kp$，再枚举左端点 $L \in [l, l + p)$，就可以覆盖所有的平方子串，这样枚举的平方子串都可以对应到不同的本原平方子串 $[L + 2(k − 1)p, L + 2kp − 1]$，然后一个串的本原平方子串个数是 $O(n log n)$ 的，所以上述方式枚举平方子串的复杂度是 $O(n log n)$ 的。还

一个串的本质不同的平方子串 的个数是 $O(n)$ 的
